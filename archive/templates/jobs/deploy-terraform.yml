# Deploy Terraform â€“ supports validate, plan and apply. Publishes plan artifact when requested.
parameters:
  - name: name
    type: string
    default: terraform
  - name: displayName
    type: string
    default: Terraform
  - name: action
    type: string
    default: plan # plan|apply
  - name: workingDirectory
    type: string
    default: "."
  - name: publishPlan
    type: boolean
    default: false
  - name: environmentName
    type: string
    default: ""
  - name: region
    type: string
    default: ""
  - name: variableRoot
    type: string
    default: "vars"
  - name: varFilesString
    type: string
    default: ""
  - name: serviceConnection
    type: string
    default: ""
  - name: dependsOn
    type: object
    default: []
  - name: useLockedSources
    type: boolean
    default: true
  - name: lockedArtifactName
    type: string
    default: source-snapshot
  - name: lockedSourcePath
    type: string
    default: $(Pipeline.Workspace)/locked-sources
  - name: tokenReplaceEnabled
    type: boolean
    default: true
  - name: tokenTargetPatterns
    type: object
    default: []
  - name: tokenPrefix
    type: string
    default: "#{"
  - name: tokenSuffix
    type: string
    default: "}"
  - name: pool
    type: object
    default: {}
  - name: demands
    type: object
    default: []
  - name: additionalRepositories
    type: object
    default: []
  - name: keyVault
    type: object
    default: {}
  - name: variableIncludeCommon
    type: boolean
    default: true
  - name: variableIncludeEnv
    type: boolean
    default: true
  - name: variableIncludeEnvRegion
    type: boolean
    default: true
  - name: variableIncludeRegionOnly
    type: boolean
    default: true

jobs:
  - job: ${{ parameters.name }}
    displayName: ${{ coalesce(parameters.displayName, upper(replace(parameters.name, '_', ' '))) }}
    dependsOn: ${{ parameters.dependsOn }}
    variables:
      - template: variables/include.yml@PipelineCommon
        parameters:
          variableRoot: ${{ parameters.variableRoot }}
          environmentName: ${{ parameters.environmentName }}
          regionName: ${{ parameters.region }}
          includeCommon: ${{ parameters.variableIncludeCommon }}
          includeRegionOnly: ${{ parameters.variableIncludeRegionOnly }}
          includeEnv: ${{ parameters.variableIncludeEnv }}
          includeEnvRegion: ${{ parameters.variableIncludeEnvRegion }}

    steps:
      # Use locked sources for RTL integrity (no fresh checkout of self)
      - ${{ if eq(parameters.useLockedSources, true) }}:
          - checkout: PipelineCommon
          - template: steps/download-artifact.yml@PipelineCommon
            parameters:
              displayName: Download source snapshot
              artifactName: ${{ parameters.lockedArtifactName }}
              downloadPath: ${{ parameters.lockedSourcePath }}
      - ${{ if eq(parameters.useLockedSources, false) }}:
          - checkout: self
          - checkout: PipelineCommon
      - ${{ if ne(coalesce(parameters.additionalRepositories, ''), '') }}:
          - ${{ each repo in parameters.additionalRepositories }}:
              - checkout: ${{ repo.alias }}

      # Optional Key Vault secret import
      - ${{ if ne(coalesce(parameters.keyVault.name, ''), '') }}:
          - template: steps/import-keyvault-secrets.yml@PipelineCommon
            parameters:
              displayName: Import Key Vault Secrets
              azureSubscription: ${{ parameters.serviceConnection }}
              keyVaultName: ${{ parameters.keyVault.name }}
              secretsFilter: ${{ coalesce(parameters.keyVault.secretsFilter, '*') }}

      # Optional token replacement (supports multiple patterns)
      - ${{ if eq(parameters.tokenReplaceEnabled, true) }}:
          - ${{ if gt(length(parameters.tokenTargetPatterns), 0) }}:
              - ${{ each tokenPattern in parameters.tokenTargetPatterns }}:
                  - template: steps/replace-tokens.yml@PipelineCommon
                    parameters:
                      displayName: Terraform token replacement (${ tokenPattern })
                      targetFiles: ${{ format('{0}/{1}', parameters.lockedSourcePath, tokenPattern) }}
                      tokenPrefix: ${{ parameters.tokenPrefix }}
                      tokenSuffix: ${{ parameters.tokenSuffix }}
          - ${{ if eq(length(parameters.tokenTargetPatterns), 0) }}:
              - template: steps/replace-tokens.yml@PipelineCommon
                parameters:
                  displayName: Terraform token replacement
                  targetFiles: ${{ format('{0}/{1}/**/*.tfvars', parameters.lockedSourcePath, parameters.workingDirectory) }}
                  tokenPrefix: ${{ parameters.tokenPrefix }}
                  tokenSuffix: ${{ parameters.tokenSuffix }}

      # Run Terraform via centralized script using AzureCLI to ensure login
      - template: steps/azurecli.yml@PipelineCommon
        parameters:
          displayName: ${{ coalesce(parameters.displayName, upper(replace(parameters.name, '_', ' '))) }} ${{ parameters.action }}
          azureSubscription: ${{ parameters.serviceConnection }}
          repoAlias: PipelineCommon
          script: terraform_run.ps1
          arguments: >-
            -Action ${{ parameters.action }}
            -WorkDir "${{ format('{0}/{1}', parameters.lockedSourcePath, parameters.workingDirectory) }}"
            -EnvironmentName "${{ parameters.environmentName }}"
            -VarFilesString "${{ parameters.varFilesString }}"
          workingDirectory: ${{ parameters.lockedSourcePath }}

      # Publish plan when requested (plan action only)
      - ${{ if and(eq(parameters.action, 'plan'), eq(parameters.publishPlan, true)) }}:
          - template: steps/publish-artifact.yml@PipelineCommon
            parameters:
              displayName: Publish Terraform Plan
              artifactName: terraform-plan-${{ parameters.environmentName }}${{ if ne(parameters.region, '') }}-${{ parameters.region }}
              targetPath: ${{ format('{0}/{1}/tfplan', parameters.lockedSourcePath, parameters.workingDirectory) }}
